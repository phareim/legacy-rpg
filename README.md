# Legacy RPG

Legacy RPG is a browser-based, AI-assisted, text adventure where the world **evolves permanently** in response to every action the player takes.  
It is built with Nuxt 3 (Vue 3 + Vite) on the client and a Nitro server running on the same codebase.  
Game state is persisted in Firebase Firestore, while narrative flavour, procedural content and world evolutions are generated by OpenAI through a thin abstraction.

---

## Table of Contents
1. [Demo](#demo)
2. [Key Features](#key-features)
3. [Architecture Overview](#architecture-overview)
4. [Project Structure](#project-structure)
5. [Data Model](#data-model)
6. [Game Loop & Command Pipeline](#game-loop--command-pipeline)
7. [REST API](#rest-api)
8. [Installation & Local Setup](#installation--local-setup)
9. [Environment Variables](#environment-variables)
10. [Seeding the World](#seeding-the-world)
11. [Scripts](#scripts)
12. [Testing](#testing)
13. [Contributing](#contributing)
14. [License](#license)

---

## Demo <a id="demo"></a>
Run `npm run dev` and navigate to <http://localhost:3000>.  You will be greeted by a command prompt.  Type `help` to see available commands or simply `north`, `take sword`, etc.

---

## Key Features <a id="key-features"></a>
â€¢ Fully interactive text adventure rendered in the browser with a retro CLI-inspired UI.  
â€¢ OpenAI powered narration, NPC dialogue, procedural locations and dynamic world **evolutions**.  
â€¢ Deterministic command parser supporting movement, item, social and utility verbs.  
â€¢ Persisted multiplayer-friendly world state in Firestore â€“ the world is **shared and permanent**.  
â€¢ Modern tech stack: Nuxt 3, TailwindCSS, TypeScript, Firebase Admin SDK.

---

## Architecture Overview <a id="architecture-overview"></a>

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       HTTP        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Nuxt 3 UI   â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  Nitro Server API  â”‚
â”‚ (Vue + TS)    â”‚                  â”‚  /api/* endpoints  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                             â”‚calls
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                       â”‚      WorldStateManager.ts          â”‚
                       â”‚  (orchestrates game mechanics)     â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚delegates
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                             â”‚                             â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CommandParser â”‚        â”‚    FirebaseService     â”‚     â”‚      AIService       â”‚
â”‚  deterministicâ”‚        â”‚ CRUD against Firestore â”‚     â”‚ OpenAI narrative &   â”‚
â”‚  intent parse â”‚        â”‚                        â”‚     â”‚ procedural content   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

1. **Client** renders components such as `GameOutput.vue` & `CommandInput.vue`.  
2. On form submit, the UI POSTs `/api/command` with `{ command, playerName }`.  
3. Nitro handler parses the command, delegates to **WorldStateManager** which:
   â€¢ consults **FirebaseService** for persisted state,  
   â€¢ updates state according to the command,  
   â€¢ optionally invokes **AIService** for narrative or evolutions,  
   â€¢ persists mutations and returns the updated `GameState` plus a formatted message.
4. The UI appends the response to the scrollable output window.

---

## Project Structure <a id="project-structure"></a>
```
â”œâ”€ components/            # Vue 3 single-file UI components
â”‚  â”œâ”€ GameInterface.vue   # layout wrapper (imports listed below)
â”‚  â”œâ”€ GameOutput.vue      # scrollable message log
â”‚  â”œâ”€ CommandInput.vue    # CLI prompt with history navigation
â”‚  â”œâ”€ PlayerStatus.vue    # HUD showing HP, location, etc.
â”‚  â””â”€ LoadingSpinner.vue  # shared spinner
â”‚
â”œâ”€ server/
â”‚  â”œâ”€ api/                # Nitro endpoints (backend-for-frontend)
â”‚  â”‚   â”œâ”€ command.post.ts # main interaction endpoint
â”‚  â”‚   â”œâ”€ game-state.get.ts
â”‚  â”‚   â””â”€ location.get.ts
â”‚  â””â”€ utils/
â”‚      â”œâ”€ worldStateManager.ts # orchestrates game logic
â”‚      â”œâ”€ commandParser.ts     # deterministic lexer/parser
â”‚      â”œâ”€ aiService.ts         # OpenAI helper
â”‚      â”œâ”€ firebaseService.ts   # Firestore wrapper
â”‚      â””â”€ seedData.ts          # helper to bootstrap world
â”‚
â”œâ”€ types/                # Shared TypeScript interfaces
â”œâ”€ public/               # Static assets
â”œâ”€ nuxt.config.ts        # Nuxt 3 configuration & runtimeConfig
â””â”€ tailwind.config.js    # TailwindCSS theme
```

---

## Data Model <a id="data-model"></a>
Key interfaces are defined in `types/game.ts`:

* **Player** â€“ name, coordinates, inventory, stats, history
* **Place**  â€“ name, description, `(x,y)` coordinates, objects, npcs, evolution_trigger
* **NPC**    â€“ name, description, inventory, memory, evolution_trigger
* **GameItem** â€“ name, description, type (`common`|`legendary`), attributes
* **GameState** â€“ `{ player, currentLocation }` returned by every API call

Firestore hierarchy:
```
/worlds/{world}/places/{x,y}
/players/{playerName}
/npcs/{npcName}
/objects/{itemName}
/storylines/{id}
```
All documents are stored in the **exact same shape** as the interfaces above, so the server code can be reused on client if needed.

---

## Game Loop & Command Pipeline <a id="game-loop--command-pipeline"></a>
1. **Input** â€“ The player enters a raw string in the prompt.  
2. **Parsing** â€“ `CommandParser.parse()` tokenises and maps it into a strongly typed `ParsedCommand` (supports movement, look/examine, inventory, take/drop/use, talk, help).  
3. **Execution** â€“ `WorldStateManager.executeCommand()` routes to specialised handlers (`handleMove`, `handleTalk`, â€¦).  
4. **Persistence** â€“ Any mutations are saved through `FirebaseService`.  
5. **Narrative** â€“ `AIService.generateNarrative()` enhances the plain result with rich prose and may call `evaluateEvolutionTriggers()` to permanently transform world entities.  
6. **Return** â€“ The final `CommandResult` is sent back to the client.

---

## REST API <a id="rest-api"></a>
| Method | Endpoint           | Body / Query | Description                             |
|--------|--------------------|--------------|-----------------------------------------|
| POST   | `/api/command`     | `{ command: string, playerName?: string }` | Parse & execute a command, returns `CommandResult`. |
| GET    | `/api/game-state`  | `?playerName=...` | Fetch the last known `GameState` (mostly for page refresh). |
| GET    | `/api/location`    | `?world=main&x=0&y=0` | Retrieve raw location data, mainly for debugging. |

All handlers are colocated in `server/api/` and can be deployed on any Nitro compatible target (Node, Edge, etc.).

---

## Installation & Local Setup <a id="installation--local-setup"></a>
```bash
# 1. Clone repository
$ git clone <repo-url> && cd legacy-rpg

# 2. Install dependencies
$ npm ci   # or yarn install or pnpm i

# 3. Configure environment
$ cp .env.example .env
# edit the file and provide the required secrets (see below)

# 4. Run development server
$ npm run dev
```
The project uses Volta-pinned Node 18+ features; any LTS â‰¥18 should work.

---

## Environment Variables <a id="environment-variables"></a>
The following variables must be available at **build time** (they are read in `nuxt.config.ts`).

| Variable | Purpose |
|----------|---------|
| `VENICE_KEY` or `OPENAI_API_KEY` | Secret used by `AIService` to access OpenAI Chat Completions API. |
| `FIREBASE_PRIVATE_KEY` | Service account private key (escaped `\n` newlines). |
| `FIREBASE_CLIENT_EMAIL` | Service account client email. |
| `FIREBASE_PROJECT_ID`  | Firebase project id (both admin & web). |
| `FIREBASE_API_KEY`     | Public web API key. |
| `FIREBASE_AUTH_DOMAIN` | `*.firebaseapp.com` domain. |
| `FIREBASE_STORAGE_BUCKET` | Storage bucket id. |
| `FIREBASE_MESSAGING_SENDER_ID` | Messaging sender id. |
| `FIREBASE_APP_ID`      | Web app id. |
| `FIREBASE_MEASUREMENT_ID` | (optional) Google Analytics id. |

> ğŸ’¡ When deploying to Vercel, set the variables as **Environment Variables** with the same names.

---

## Seeding the World <a id="seeding-the-world"></a>
Run the helper once to bootstrap Firestore with starter places, NPCs and items:
```ts
import { SeedData } from '~/server/utils/seedData'
await SeedData.initializeWorld()
```
You can execute the snippet in a Node REPL or create a temporary Nitro endpoint.  Remove the call afterwards to avoid accidental re-seeding.

---

## Scripts <a id="scripts"></a>
| Script | Description |
|--------|-------------|
| `npm run dev` | Launch Nuxt in development with HMR. |
| `npm run build` | Generate the production server & static assets. |
| `npm run preview` | Start the built server locally for testing. |
| `npm run generate` | _(optional)_ Pre-generate static pages. |

---

## Testing <a id="testing"></a>
No automated tests yet.  PRs with **Vitest** or **Cypress** suites are welcome!

---

## Contributing <a id="contributing"></a>
1. Fork & clone the repo.  
2. Create a feature branch: `git checkout -b feat/my-awesome-thing`.  
3. Install dependencies & run the linter optionally.  
4. Submit a PR describing your changes.  

Please follow the existing coding style â€“ TypeScript wherever possible, compositional functions and descriptive commit messages.

---

## License <a id="license"></a>
Distributed under the MIT License â€“ see `LICENSE` for details.
