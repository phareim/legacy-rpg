# Legacy RPG

Legacy RPG is a browser-based, AI-assisted, text adventure where the world **evolves permanently** in response to every action the player takes.  
It is built with Nuxt 3 (Vue 3 + Vite) on the client and a Nitro server running on the same codebase.  
Game state is persisted in Firebase Firestore, while narrative flavour, procedural content and world evolutions are generated by OpenAI through a thin abstraction.

---

## Table of Contents
1. [Demo](#demo)
2. [Key Features](#key-features)
3. [Architecture Overview](#architecture-overview)
4. [Project Structure](#project-structure)
5. [Data Model](#data-model)
6. [Game Loop & Command Pipeline](#game-loop--command-pipeline)
7. [REST API](#rest-api)
8. [Installation & Local Setup](#installation--local-setup)
9. [Environment Variables](#environment-variables)
10. [Seeding the World](#seeding-the-world)
11. [Scripts](#scripts)
12. [Testing](#testing)
13. [Contributing](#contributing)
14. [License](#license)

---

## Demo <a id="demo"></a>
Run `npm run dev` and navigate to <http://localhost:3000>.  You will be greeted by a command prompt.  Type `help` to see available commands or simply `north`, `take sword`, etc.

---

## Key Features <a id="key-features"></a>
• Fully interactive text adventure rendered in the browser with a retro CLI-inspired UI.  
• OpenAI powered narration, NPC dialogue, procedural locations and dynamic world **evolutions**.  
• Deterministic command parser supporting movement, item, social and utility verbs.  
• Persisted multiplayer-friendly world state in Firestore – the world is **shared and permanent**.  
• Modern tech stack: Nuxt 3, TailwindCSS, TypeScript, Firebase Admin SDK.

---

## Architecture Overview <a id="architecture-overview"></a>

```
┌───────────────┐       HTTP        ┌────────────────────┐
│   Nuxt 3 UI   │  ───────────────►│  Nitro Server API  │
│ (Vue + TS)    │                  │  /api/* endpoints  │
└───────────────┘                  └─────────┬──────────┘
                                             │calls
                       ┌─────────────────────┴──────────────┐
                       │      WorldStateManager.ts          │
                       │  (orchestrates game mechanics)     │
                       └──────────────┬─────────────────────┘
                                      │delegates
        ┌─────────────────────────────┼─────────────────────────────┐
        │                             │                             │
┌───────────────┐        ┌────────────────────────┐     ┌──────────────────────┐
│ CommandParser │        │    FirebaseService     │     │      AIService       │
│  deterministic│        │ CRUD against Firestore │     │ OpenAI narrative &   │
│  intent parse │        │                        │     │ procedural content   │
└───────────────┘        └────────────────────────┘     └──────────────────────┘
```

1. **Client** renders components such as `GameOutput.vue` & `CommandInput.vue`.  
2. On form submit, the UI POSTs `/api/command` with `{ command, playerName }`.  
3. Nitro handler parses the command, delegates to **WorldStateManager** which:
   • consults **FirebaseService** for persisted state,  
   • updates state according to the command,  
   • optionally invokes **AIService** for narrative or evolutions,  
   • persists mutations and returns the updated `GameState` plus a formatted message.
4. The UI appends the response to the scrollable output window.

---

## Project Structure <a id="project-structure"></a>
```
├─ components/            # Vue 3 single-file UI components
│  ├─ GameInterface.vue   # layout wrapper (imports listed below)
│  ├─ GameOutput.vue      # scrollable message log
│  ├─ CommandInput.vue    # CLI prompt with history navigation
│  ├─ PlayerStatus.vue    # HUD showing HP, location, etc.
│  └─ LoadingSpinner.vue  # shared spinner
│
├─ server/
│  ├─ api/                # Nitro endpoints (backend-for-frontend)
│  │   ├─ command.post.ts # main interaction endpoint
│  │   ├─ game-state.get.ts
│  │   └─ location.get.ts
│  └─ utils/
│      ├─ worldStateManager.ts # orchestrates game logic
│      ├─ commandParser.ts     # deterministic lexer/parser
│      ├─ aiService.ts         # OpenAI helper
│      ├─ firebaseService.ts   # Firestore wrapper
│      └─ seedData.ts          # helper to bootstrap world
│
├─ types/                # Shared TypeScript interfaces
├─ public/               # Static assets
├─ nuxt.config.ts        # Nuxt 3 configuration & runtimeConfig
└─ tailwind.config.js    # TailwindCSS theme
```

---

## Data Model <a id="data-model"></a>
Key interfaces are defined in `types/game.ts`:

* **Player** – name, coordinates, inventory, stats, history
* **Place**  – name, description, `(x,y)` coordinates, objects, npcs, evolution_trigger
* **NPC**    – name, description, inventory, memory, evolution_trigger
* **GameItem** – name, description, type (`common`|`legendary`), attributes
* **GameState** – `{ player, currentLocation }` returned by every API call

Firestore hierarchy:
```
/worlds/{world}/places/{x,y}
/players/{playerName}
/npcs/{npcName}
/objects/{itemName}
/storylines/{id}
```
All documents are stored in the **exact same shape** as the interfaces above, so the server code can be reused on client if needed.

---

## Game Loop & Command Pipeline <a id="game-loop--command-pipeline"></a>
1. **Input** – The player enters a raw string in the prompt.  
2. **Parsing** – `CommandParser.parse()` tokenises and maps it into a strongly typed `ParsedCommand` (supports movement, look/examine, inventory, take/drop/use, talk, help).  
3. **Execution** – `WorldStateManager.executeCommand()` routes to specialised handlers (`handleMove`, `handleTalk`, …).  
4. **Persistence** – Any mutations are saved through `FirebaseService`.  
5. **Narrative** – `AIService.generateNarrative()` enhances the plain result with rich prose and may call `evaluateEvolutionTriggers()` to permanently transform world entities.  
6. **Return** – The final `CommandResult` is sent back to the client.

---

## REST API <a id="rest-api"></a>
| Method | Endpoint           | Body / Query | Description                             |
|--------|--------------------|--------------|-----------------------------------------|
| POST   | `/api/command`     | `{ command: string, playerName?: string }` | Parse & execute a command, returns `CommandResult`. |
| GET    | `/api/game-state`  | `?playerName=...` | Fetch the last known `GameState` (mostly for page refresh). |
| GET    | `/api/location`    | `?world=main&x=0&y=0` | Retrieve raw location data, mainly for debugging. |

All handlers are colocated in `server/api/` and can be deployed on any Nitro compatible target (Node, Edge, etc.).

---

## Installation & Local Setup <a id="installation--local-setup"></a>
```bash
# 1. Clone repository
$ git clone <repo-url> && cd legacy-rpg

# 2. Install dependencies
$ npm ci   # or yarn install or pnpm i

# 3. Configure environment
$ cp .env.example .env
# edit the file and provide the required secrets (see below)

# 4. Run development server
$ npm run dev
```
The project uses Volta-pinned Node 18+ features; any LTS ≥18 should work.

---

## Environment Variables <a id="environment-variables"></a>
The following variables must be available at **build time** (they are read in `nuxt.config.ts`).

| Variable | Purpose |
|----------|---------|
| `VENICE_KEY` or `OPENAI_API_KEY` | Secret used by `AIService` to access OpenAI Chat Completions API. |
| `FIREBASE_PRIVATE_KEY` | Service account private key (escaped `\n` newlines). |
| `FIREBASE_CLIENT_EMAIL` | Service account client email. |
| `FIREBASE_PROJECT_ID`  | Firebase project id (both admin & web). |
| `FIREBASE_API_KEY`     | Public web API key. |
| `FIREBASE_AUTH_DOMAIN` | `*.firebaseapp.com` domain. |
| `FIREBASE_STORAGE_BUCKET` | Storage bucket id. |
| `FIREBASE_MESSAGING_SENDER_ID` | Messaging sender id. |
| `FIREBASE_APP_ID`      | Web app id. |
| `FIREBASE_MEASUREMENT_ID` | (optional) Google Analytics id. |

> 💡 When deploying to Vercel, set the variables as **Environment Variables** with the same names.

---

## Seeding the World <a id="seeding-the-world"></a>
Run the helper once to bootstrap Firestore with starter places, NPCs and items:
```ts
import { SeedData } from '~/server/utils/seedData'
await SeedData.initializeWorld()
```
You can execute the snippet in a Node REPL or create a temporary Nitro endpoint.  Remove the call afterwards to avoid accidental re-seeding.

---

## Scripts <a id="scripts"></a>
| Script | Description |
|--------|-------------|
| `npm run dev` | Launch Nuxt in development with HMR. |
| `npm run build` | Generate the production server & static assets. |
| `npm run preview` | Start the built server locally for testing. |
| `npm run generate` | _(optional)_ Pre-generate static pages. |

---

## Testing <a id="testing"></a>
No automated tests yet.  PRs with **Vitest** or **Cypress** suites are welcome!

---

## Contributing <a id="contributing"></a>
1. Fork & clone the repo.  
2. Create a feature branch: `git checkout -b feat/my-awesome-thing`.  
3. Install dependencies & run the linter optionally.  
4. Submit a PR describing your changes.  

Please follow the existing coding style – TypeScript wherever possible, compositional functions and descriptive commit messages.

---

## License <a id="license"></a>
Distributed under the MIT License – see `LICENSE` for details.
